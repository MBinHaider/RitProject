---
title: "RitProject_Project"
author: "Mohammad Bin Haider"
date: "`r Sys.Date()`"
output:
  html_document: default
  pdf_document: default
---

```{r}
# Load necessary libraries
# Install tidyr if not already installed
if (!require(tidyr)) install.packages("tidyr")
library(tidyr)
library(ggplot2)
library(dplyr)
library(DataExplorer)

# Load the dataset
data <- read.csv("car_price.csv")

# --- Data Profiling ---

# Dataset dimensions
cat("---- Dataset Overview ----\n")
cat("Dataset dimensions: ", dim(data), "\n")  # Rows and columns
cat("Column names: ", names(data), "\n")  # List of column names

# Data types and structure
cat("\n---- Data Types and Structure ----\n")
print(str(data))  # Structure of the dataset

# Summary statistics for numeric and categorical columns
cat("\n---- Summary Statistics ----\n")
print(summary(data))


```

```{r echo=TRUE}
# --- Convert Data Types ---
cat("\n---- Convert IDs and Categorical Columns to Appropriate Types ----\n")
data$car_ID <- as.factor(data$car_ID)  # Assuming car_ID is an identifier
data$symboling <- as.factor(data$symboling)  # Assuming symboling is a categorical variable
data$fueltype <- as.factor(data$fueltype)
data$aspiration <- as.factor(data$aspiration)
data$doornumber <- as.factor(data$doornumber)
data$carbody <- as.factor(data$carbody)
data$drivewheel <- as.factor(data$drivewheel)
data$enginelocation <- as.factor(data$enginelocation)
data$enginetype <- as.factor(data$enginetype)
data$cylindernumber <- as.factor(data$cylindernumber)
data$fuelsystem <- as.factor(data$fuelsystem)



```

```{r echo=TRUE}
# --- Check for Missing Values ---
cat("\n---- Missing Values Check ----\n")

missing_values <- colSums(is.na(data))
cat("Missing values in each column:\n")
print(missing_values)

# --- Handling Missing Values ---
cat("\n---- Handling Missing Values ----\n")

# Numeric columns: Median imputation
numeric_cols <- names(data)[sapply(data, is.numeric)]
for (col in numeric_cols) {
  if (sum(is.na(data[[col]])) > 0) {
    data[[col]][is.na(data[[col]])] <- median(data[[col]], na.rm = TRUE)
    cat(sprintf("Missing values in numeric column '%s' filled with median.\n", col))
  }
}

# Categorical columns: Mode imputation
categorical_cols <- names(data)[sapply(data, is.character)]
for (col in categorical_cols) {
  if (sum(is.na(data[[col]])) > 0) {
    mode_value <- names(which.max(table(data[[col]], useNA = "no")))
    data[[col]][is.na(data[[col]])] <- mode_value
    cat(sprintf("Missing values in categorical column '%s' filled with mode '%s'.\n", col, mode_value))
  }
}

# Final Check: Verify all missing values have been handled
cat("\n---- Final Missing Values Check ----\n")
final_missing_values <- colSums(is.na(data))
cat("Remaining missing values in each column (should be 0):\n")
print(final_missing_values)

```


```{r echo=TRUE}

# --- Check for Duplicates ---
cat("\n---- Checking for Duplicates ----\n")

# Calculate the number of duplicate rows
num_duplicates <- nrow(data) - nrow(dplyr::distinct(data))
cat(sprintf("Number of duplicate rows: %d\n", num_duplicates))

# --- Handle Duplicates ---
cat("\n---- Handling for Duplicates ----\n")

if (num_duplicates > 0) {
  cat("\nDuplicates found. Removing duplicate rows...\n")
  data <- dplyr::distinct(data)
  cat(sprintf("Duplicates removed. Remaining rows: %d\n", nrow(data)))
} else {
  cat("\nNo duplicates found. Dataset remains unchanged.\n")
}

# --- Final Check ---
cat("\n---- Final Duplicate Check ----\n")
final_num_duplicates <- nrow(data) - nrow(dplyr::distinct(data))
if (final_num_duplicates == 0) {
  cat("Success: No duplicate rows exist.\n")
} else {
  cat(sprintf("Warning: %d duplicate rows remain after handling.\n", final_num_duplicates))
}
```

```{r echo=TRUE}
# --- Check Outliers in Numerical Columns ---
cat("\n---- Identifying Columns with Outliers ----\n")

# Loop through numeric columns and create colorful boxplots
numeric_cols <- names(data)[sapply(data, is.numeric)]

for (col in numeric_cols) {
  # Create and display a boxplot for each numeric column
  plot <- ggplot(data, aes(x = "", y = .data[[col]])) +
    geom_boxplot(outlier.colour = "red", outlier.shape = 16, outlier.size = 3, fill = "skyblue", color = "darkblue") +
    labs(
      title = paste("Boxplot of", col, "- Outliers Highlighted"),
      x = "", y = col
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
      axis.title.y = element_text(size = 12, face = "bold"),
      axis.text.y = element_text(size = 10)
    ) +
    scale_y_continuous(labels = scales::comma)  # Add commas for large numbers
  
  print(plot)
}

# --- Handling Outliers Using Capping ---
cat("\n---- Handling Outliers Using Capping ----\n")

# Function to identify outliers using the IQR method
identify_outliers <- function(column) {
  Q1 <- quantile(column, 0.25, na.rm = TRUE)  # First quartile (25th percentile)
  Q3 <- quantile(column, 0.75, na.rm = TRUE)  # Third quartile (75th percentile)
  IQR <- Q3 - Q1                             # Interquartile range
  lower_bound <- Q1 - 1.5 * IQR              # Lower bound
  upper_bound <- Q3 + 1.5 * IQR              # Upper bound
  return(list(lower_bound = lower_bound, upper_bound = upper_bound))
}

# Handle outliers for each numeric column
for (col in numeric_cols) {
  # Identify bounds
  bounds <- identify_outliers(data[[col]])
  lower_bound <- bounds$lower_bound
  upper_bound <- bounds$upper_bound
  
  # Count affected rows
  outlier_indices <- which(data[[col]] < lower_bound | data[[col]] > upper_bound)
  num_outliers <- length(outlier_indices)
  total_values <- sum(!is.na(data[[col]]))  # Total non-NA values
  outlier_percentage <- (num_outliers / total_values) * 100  # Calculate percentage
  
  if (num_outliers > 0) {
    # Cap outliers to the lower and upper bounds
    data[[col]][data[[col]] < lower_bound] <- lower_bound
    data[[col]][data[[col]] > upper_bound] <- upper_bound
    
    # Log the results with improved formatting
    cat(sprintf("Column: %-15s | Outliers: %-4d | Percentage: %-6.2f%% | Bounds: [%.2f, %.2f]\n",
                col, num_outliers, outlier_percentage, lower_bound, upper_bound))
  } else {
    cat(sprintf("Column: %-15s | Outliers: None\n", col))
  }
}

# --- Why Use Capping for Predicting Car Prices? ---
cat("\n---- Why Use Capping for Predicting Car Prices? ----\n")
cat(
  "1. Outliers in car prices may represent rare but valid cases (e.g., luxury cars).\n",
  "2. Removing outliers could result in the loss of important information critical for predicting prices.\n",
  "3. Capping limits the influence of extreme values without discarding data, ensuring the model learns from all cases.\n"
)

```
```{r echo=TRUE}
# --- Boxplots for Categorical Variables vs Price (Excluding Null/Empty Values) ---
cat("\n---- Boxplots for Categorical Variables Against Price (Excluding Null/Empty Values) ----\n")

library(ggplot2)
library(dplyr)

# Identify categorical columns
categorical_cols <- names(data)[sapply(data, is.character)]
cat("Categorical Columns Identified:\n")
print(categorical_cols)

# Clean data by removing rows with NA or empty values in price or categorical variables
data_cleaned <- data %>%
  filter(!is.na(price)) %>%
  filter(!apply(., 1, function(row) any(is.na(row) | row == "")))

# Ensure 'data_cleaned' is properly created
if (nrow(data_cleaned) == 0) {
  stop("Error: The dataset 'data_cleaned' is empty after removing null or empty values.")
}

# Loop through categorical columns and create boxplots
for (col in categorical_cols) {
  if (col == "CarName") {
    # Handle 'CarName' by selecting top 10 categories by mode (most frequent)
    cat(sprintf("\nColumn '%s' has many categories. Selecting top 10 by frequency.\n", col))
    
    # Get the top 10 most frequent CarNames
    top_cars <- data_cleaned %>%
      count(CarName) %>%
      arrange(desc(n)) %>%
      slice(1:10)  # Select top 10 by frequency
    
    # Filter cleaned data to include only top 10 categories
    filtered_data <- data_cleaned %>% filter(CarName %in% top_cars$CarName)
    
    # Create boxplot for top 10 car names by mode
    plot <- ggplot(filtered_data, aes(x = reorder(CarName, price, FUN = median), y = price, fill = CarName)) +
      geom_boxplot(outlier.colour = "red", outlier.shape = 16, outlier.size = 2) +
      labs(
        title = "Price Distribution by Top 10 Most Frequent Car Names",
        x = "Car Name",
        y = "Price"
      ) +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        axis.title.x = element_text(size = 12, face = "bold"),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1)
      ) +
      scale_y_continuous(labels = scales::comma)
    
    # Display the plot
    print(plot)
  } else {
    # Standard boxplot for other categorical variables
    filtered_data <- data_cleaned %>%
      filter(!is.na(.data[[col]]) & .data[[col]] != "")
    
    plot <- ggplot(filtered_data, aes_string(x = col, y = "price", fill = col)) +
      geom_boxplot(outlier.colour = "red", outlier.shape = 16, outlier.size = 2) +
      labs(
        title = paste("Price Distribution by", col),
        x = col,
        y = "Price"
      ) +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        axis.title.x = element_text(size = 12, face = "bold"),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.text.x = element_text(angle = 45, hjust = 1)
      ) +
      scale_y_continuous(labels = scales::comma)
    
    # Display the plot
    print(plot)
  }
}

# --- Why Visualize Top 10 Most Frequent Car Names? ---
cat("\n---- Why Visualize Top 10 Most Frequent Car Names? ----\n")
cat(
  "Visualizing the top 10 most frequent car names provides a clear and focused analysis of pricing trends for popular models. 
  Since 'CarName' has a large number of unique categories, including all of them in a single visualization would lead to clutter 
  and make it difficult to interpret the data. By limiting the analysis to the most frequent categories, we can ensure that the 
  visualization remains meaningful and actionable. This approach highlights patterns and trends in pricing for cars that are 
  most relevant to our analysis while avoiding the noise introduced by less frequent categories.\n\n"
)

# --- How We Handled Missing Values ---
cat("\n---- How We Handled Missing Values ----\n")
cat(
  "To ensure accurate and clean visualizations, we also handled missing (NA) and null values in the dataset. Rows with missing values 
  in the 'price' column or any categorical variable were excluded from the analysis. This was achieved by applying the following steps:\n
  1. Filtering out rows where 'price' was NA.\n
  2. Removing rows where any categorical column had an NA or empty string value.\n
  By performing this cleaning step, we ensured that the data used for visualization is complete and reliable, making the analysis 
  robust and free from biases introduced by incomplete data."
)


```

``` {r}
# --- Scatterplots for Numerical Variables vs Price ---
cat("\n---- Scatterplots for Numerical Variables Against Price ----\n")

library(ggplot2)

# Clean data by removing rows with NA or empty values in price or numerical variables
data_cleaned <- data %>%
  filter(!is.na(price)) %>%
  filter(!apply(., 1, function(row) any(is.na(row))))

# Identify numerical columns
numeric_cols <- names(data_cleaned)[sapply(data_cleaned, is.numeric)]
cat("Numerical Columns Identified:\n")
print(numeric_cols)

# Loop through numerical columns and create scatterplots
for (col in numeric_cols) {
  if (col != "price") {  # Exclude 'price' from comparison
    cat(sprintf("\nCreating scatterplot for '%s' vs 'price'.\n", col))
    
    # Create scatterplot with coloring based on 'CarName'
    plot <- ggplot(data_cleaned, aes_string(x = col, y = "price")) +
      geom_point(aes(color = CarName), alpha = 0.5) +
      geom_smooth(method = "lm", color = "red", se = FALSE) +
      labs(
        title = paste("Relationship Between", col, "and Price"),
        x = col,
        y = "Price"
      ) +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
        axis.title.x = element_text(size = 12, face = "bold"),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        legend.position = "none"  # Optional: remove legend if CarName has too many values
      ) +
      scale_y_continuous(labels = scales::comma) +  # Format y-axis with commas
      scale_x_continuous(labels = scales::comma)    # Format x-axis with commas
    
    # Display the plot
    print(plot)
  }
}

# --- Why Visualize Numerical Variables Against Price? ---
cat("\n---- Why Visualize Numerical Variables Against Price? ----\n")
cat(
  "Scatterplots for numerical variables against 'price' help identify patterns, trends, and potential relationships in the data. 
  By using points colored by 'CarName', we can observe differences between car models while highlighting correlations with linear trendlines. 
  This analysis is crucial for understanding which numerical features have significant impacts on price."
)
```
