---
title: "RitProject_Project"
author: "Mohammad Bin Haider"
date: "`r Sys.Date()`"
output: html_document
---

```{r}
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(DataExplorer)

# Load the dataset
data <- read.csv("car_price.csv")

# --- Data Profiling ---

# Dataset dimensions
cat("---- Dataset Overview ----\n")
cat("Dataset dimensions: ", dim(data), "\n")  # Rows and columns
cat("Column names: ", names(data), "\n")  # List of column names

# Data types and structure
cat("\n---- Data Types and Structure ----\n")
print(str(data))  # Structure of the dataset

# Summary statistics for numeric and categorical columns
cat("\n---- Summary Statistics ----\n")
print(summary(data))


```

```{r echo=TRUE}
# --- Convert Data Types ---
cat("\n---- Convert IDs and Categorical Columns to Appropriate Types ----\n")
data$car_ID <- as.factor(data$car_ID)  # Assuming car_ID is an identifier
data$symboling <- as.factor(data$symboling)  # Assuming symboling is a categorical variable
data$fueltype <- as.factor(data$fueltype)
data$aspiration <- as.factor(data$aspiration)
data$doornumber <- as.factor(data$doornumber)
data$carbody <- as.factor(data$carbody)
data$drivewheel <- as.factor(data$drivewheel)
data$enginelocation <- as.factor(data$enginelocation)
data$enginetype <- as.factor(data$enginetype)
data$cylindernumber <- as.factor(data$cylindernumber)
data$fuelsystem <- as.factor(data$fuelsystem)



```

```{r echo=TRUE}
# --- Check for Missing Values ---
cat("\n---- Missing Values Check ----\n")

missing_values <- colSums(is.na(data))
cat("Missing values in each column:\n")
print(missing_values)

# --- Handling Missing Values ---
cat("\n---- Handling Missing Values ----\n")

# Numeric columns: Median imputation
numeric_cols <- names(data)[sapply(data, is.numeric)]
for (col in numeric_cols) {
  if (sum(is.na(data[[col]])) > 0) {
    data[[col]][is.na(data[[col]])] <- median(data[[col]], na.rm = TRUE)
    cat(sprintf("Missing values in numeric column '%s' filled with median.\n", col))
  }
}

# Categorical columns: Mode imputation
categorical_cols <- names(data)[sapply(data, is.character)]
for (col in categorical_cols) {
  if (sum(is.na(data[[col]])) > 0) {
    mode_value <- names(which.max(table(data[[col]], useNA = "no")))
    data[[col]][is.na(data[[col]])] <- mode_value
    cat(sprintf("Missing values in categorical column '%s' filled with mode '%s'.\n", col, mode_value))
  }
}

# Final Check: Verify all missing values have been handled
cat("\n---- Final Missing Values Check ----\n")
final_missing_values <- colSums(is.na(data))
cat("Remaining missing values in each column (should be 0):\n")
print(final_missing_values)

```


```{r echo=TRUE}

# --- Check for Duplicates ---
cat("\n---- Checking for Duplicates ----\n")

# Calculate the number of duplicate rows
num_duplicates <- nrow(data) - nrow(dplyr::distinct(data))
cat(sprintf("Number of duplicate rows: %d\n", num_duplicates))

# --- Handle Duplicates ---
cat("\n---- Handling for Duplicates ----\n")

if (num_duplicates > 0) {
  cat("\nDuplicates found. Removing duplicate rows...\n")
  data <- dplyr::distinct(data)
  cat(sprintf("Duplicates removed. Remaining rows: %d\n", nrow(data)))
} else {
  cat("\nNo duplicates found. Dataset remains unchanged.\n")
}

# --- Final Check ---
cat("\n---- Final Duplicate Check ----\n")
final_num_duplicates <- nrow(data) - nrow(dplyr::distinct(data))
if (final_num_duplicates == 0) {
  cat("Success: No duplicate rows exist.\n")
} else {
  cat(sprintf("Warning: %d duplicate rows remain after handling.\n", final_num_duplicates))
}
```

```{r echo=TRUE}
# --- Check Outliers in Numerical Columns ---
cat("\n---- Identifying Columns with Outliers ----\n")

# Loop through numeric columns and create colorful boxplots
numeric_cols <- names(data)[sapply(data, is.numeric)]

for (col in numeric_cols) {
  # Create and display a boxplot for each numeric column
  plot <- ggplot(data, aes(x = "", y = .data[[col]])) +
    geom_boxplot(outlier.colour = "red", outlier.shape = 16, outlier.size = 3, fill = "skyblue", color = "darkblue") +
    labs(
      title = paste("Boxplot of", col, "- Outliers Highlighted"),
      x = "", y = col
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
      axis.title.y = element_text(size = 12, face = "bold"),
      axis.text.y = element_text(size = 10)
    ) +
    scale_y_continuous(labels = scales::comma)  # Add commas for large numbers
  
  print(plot)
}

# --- Handling Outliers Using Capping ---
cat("\n---- Handling Outliers Using Capping ----\n")

# Function to identify outliers using the IQR method
identify_outliers <- function(column) {
  Q1 <- quantile(column, 0.25, na.rm = TRUE)  # First quartile (25th percentile)
  Q3 <- quantile(column, 0.75, na.rm = TRUE)  # Third quartile (75th percentile)
  IQR <- Q3 - Q1                             # Interquartile range
  lower_bound <- Q1 - 1.5 * IQR              # Lower bound
  upper_bound <- Q3 + 1.5 * IQR              # Upper bound
  return(list(lower_bound = lower_bound, upper_bound = upper_bound))
}

# Handle outliers for each numeric column
for (col in numeric_cols) {
  # Identify bounds
  bounds <- identify_outliers(data[[col]])
  lower_bound <- bounds$lower_bound
  upper_bound <- bounds$upper_bound
  
  # Count affected rows
  outlier_indices <- which(data[[col]] < lower_bound | data[[col]] > upper_bound)
  num_outliers <- length(outlier_indices)
  total_values <- sum(!is.na(data[[col]]))  # Total non-NA values
  outlier_percentage <- (num_outliers / total_values) * 100  # Calculate percentage
  
  if (num_outliers > 0) {
    # Cap outliers to the lower and upper bounds
    data[[col]][data[[col]] < lower_bound] <- lower_bound
    data[[col]][data[[col]] > upper_bound] <- upper_bound
    
    # Log the results with improved formatting
    cat(sprintf("Column: %-15s | Outliers: %-4d | Percentage: %-6.2f%% | Bounds: [%.2f, %.2f]\n",
                col, num_outliers, outlier_percentage, lower_bound, upper_bound))
  } else {
    cat(sprintf("Column: %-15s | Outliers: None\n", col))
  }
}

# --- Why Use Capping for Predicting Car Prices? ---
cat("\n---- Why Use Capping for Predicting Car Prices? ----\n")
cat(
  "1. Outliers in car prices may represent rare but valid cases (e.g., luxury cars).\n",
  "2. Removing outliers could result in the loss of important information critical for predicting prices.\n",
  "3. Capping limits the influence of extreme values without discarding data, ensuring the model learns from all cases.\n"
)

```


